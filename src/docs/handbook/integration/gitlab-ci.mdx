---
title: GitLab CI
---

export const PlaywrightVersion = () => <SupportedIntegrationVersion name="playwright-core" format="exact" />;

# GitLab CI

Serenity/JS offers excellent support for [GitLab CI](https://docs.gitlab.com/topics/build_your_application/):
you can run your acceptance tests in CI, generate rich Serenity BDD reports,
and publish both living documentation and JUnit-style test results.

In this guide, you'll learn how to configure your GitLab CI pipeline to use the official Serenity/JS Docker image
and ensure a stable environment for running your Serenity/JS test scenarios.

## Before you start

Set up a working Serenity/JS test suite using one of the official [Serenity/JS Project Templates](/handbook/project-templates/),
or add Serenity/JS to your existing project by following the [Serenity/JS installation guide](/handbook/installation/).

If you're new to Serenity/JS, [follow the tutorial](/handbook/tutorials/your-first-web-scenario) to learn more about the framework.

## Running Serenity/JS on GitLab CI

GitLab CI executes pipelines inside [Docker containers](https://docs.gitlab.com/ee/ci/docker/using_docker_images.html).

To ensure stability of your execution environment, use a container with:
- The latest Long-Term Support (LTS) version of [Node.js](https://github.com/nodejs/Release)
- A recent Java Runtime Environment (JRE)
- Your desired web browsers and other dependencies, as per the [Serenity/JS installation guide](/handbook/installation/)

The easiest way to do that is to:
- Use the official [Serenity/JS Docker image](/handbook/integration/docker/) directly, as it comes pre-configured with all the required dependencies
- Create a [custom Docker container](/handbook/integration/docker/#extending-serenityjs-docker-images) based on the official Serenity/JS Docker image to suit your needs

## Configuring GitLab CI pipelines

GitLab CI pipelines are configured using a file called [`.gitlab-ci.yml`](https://docs.gitlab.com/ci/yaml/), located at the root of your repository.

A typical Serenity/JS GitLab CI pipeline consists of at least two stages:
- `test` - responsible for running your Serenity/JS test scenarios and collecting their artifacts
- `publish` - responsible for publishing artifacts, such as the Serenity reports, to GitLab Pages or other destinations

:::tip Pipeline naming conventions
Neither GitLab CI nor Serenity/JS force you to use any particular naming convention or structure for your pipelines.
In this guide, we use `test` and `publish` as that's a great starting point and a convention often followed by teams using Serenity/JS.
:::

In the example below, you see the `test` stage with a job called `serenity` that:
- Uses the official [Serenity/JS Playwright Docker image](/handbook/integration/docker/#serenityjs-playwright-image)
- Installs the project dependencies using `npm ci`, which is the recommended way to install Node.js modules in CI environments
- Runs the test suite using `npm test` - all [Serenity/JS Project Templates](/handbook/project-templates/) are pre-configured to run tests and generate reports via this standard script,
  and you can adjust it to your needs if necessary
- Preserves any artifacts under `target`, including the Serenity BDD reports, so that they can be reused in subsequent stages of the pipeline

The `publish` stage has a job called `create-pages` that:
- Declares a dependency on the `serenity` job to access its artifacts
- Uses the [`pages`](https://docs.gitlab.com/ci/yaml/#pages) keyword to specify the location of the report
- Uses the [`rules`](https://docs.gitlab.com/ci/yaml/#rules) keyword to publish the reports only when the pipeline runs on the default branch. This helps to avoid overwriting the main branch report when working on feature branches

<DynamicCodeBlock title=".gitlab-ci.yml" lang="yaml">
{`stages:
  - test
  - publish

  serenity:
    stage: test

    # Use the official Serenity/JS Docker image
    image: ghcr.io/serenity-js/playwright:v`}<PlaywrightVersion />{`-noble

    script:
    - npm ci
    - npm test

    # Preserve test artifacts, even when the job fails
    artifacts:
      when: always
      paths:
        - target

  create-pages:
    stage: publish
    pages:
      publish: target/site/serenity

    dependencies:
      - serenity

    script:
      - echo "Publishing Serenity reports"

    # Publish reports to GitLab Pages only on the default branch
    rules:
      - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

  # other configuration
`}
</DynamicCodeBlock>

If your team uses merge requests in your workflow, you might want to use [GitLab Parallel Deployments](https://docs.gitlab.com/user/project/pages/parallel_deployments/)
to publish an instance of Serenity reports per merge request.

## Generating JUnit reports

GitLab CI recognises test execution reports that conform to the [JUnit XML standard](https://llg.cubic.org/docs/junit/).
Serenity/JS integrates with all the **native reporters** offered by the supported [test runners](/handbook/test-runners/),
including the ones producing JUnit reports, such as:
- [Cucumber.js JUnit formatter](https://github.com/cucumber/cucumber-js/blob/main/docs/formatters.md#junit)
- [Jasmine JUnit reporter](https://www.npmjs.com/package/jasmine-reporters)
- [Mocha JUnit reporter](https://www.npmjs.com/package/mocha-junit-reporter)
- [Playwright Test JUnit reporter](https://playwright.dev/docs/test-reporters#junit-reporter)
- [WebdriverIO](https://webdriver.io/docs/junit-reporter/)

To make GitLab CI recognise a JUnit-standard report produced by your Serenity/JS test suite and [surface test results in your Merge Requests](https://docs.gitlab.com/ee/ci/testing/unit_test_reports.html), you should:
- Use a native JUnit reporter appropriate for your test runner
- Configure [`artifacts:reports:junit`](https://docs.gitlab.com/ee/ci/testing/unit_test_reports.html)  to tell GitLab where to find the report.

For example, if you have configured your JUnit reporter to produce a report at `target/junit-results.xml`, you can configure your GitLab CI job as follows:

```yaml title=".gitlab-ci.yml"
stages:
  - test

serenity:
  stage: test
  # ...
  artifacts:
    when: always
    paths:
      - target
    # highlight-start
    reports:
      junit: target/junit-results.xml
    # highlight-end

# other configuration
```

:::tip Pro Tip
Note that in the above example I use [`artifacts:when: always`](https://docs.gitlab.com/ee/ci/yaml/#artifactswhen).
This instructs GitLab to upload and analyse the test report even when the test run fails, which is exactly when you need your test reports the most ðŸ˜Š
:::
